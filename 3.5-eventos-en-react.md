# 3.5 Eventos en React

## Contenidos

* [EJERCICIO 1]()
* [EJERCICIO 2]()
* [EJERCICIO 3]()
* [EJERCICIO 4]()
* [EJERCICIO 5]()
* [EJERCICIO 6]()
* [EJERCICIO 7]()

## Introducción

Hasta ahora sólo hemos visto cómo pintar interfaces estáticas o independientes en React. Esta es la sesión divertida: en esta sesión veremos cómo añadir dinamismo a los componentes con eventos.

Vamos a ver que los eventos nos permiten declarar qué reacciones tendrán nuestros componentes. En ocasiones necesitamos que un componente padre/madre reaccione a un cambio ocurrido en un hijo/a.

React solo nos permite pasar datos unidireccionalmente, de padres/madres a hijos/hijas. Aunque esto puede parecer una limitación, debemos recordar que las funciones en JavaScript se tratan como datos, podemos guardarlas en variables, y conservan las variables del ámbito donde se declararon. Así que, ¿y si declarásemos una función en el padre/madre que provoque una reacción en el propio componente y se la pasamos como `prop` a un hijo/a? Eso es una **práctica habitual en React** que se llama _lifting_, que significa "alzamiento".

## ¿Para qué sirve lo que vamos a ver en esta sesión?

React tiene un sistema de eventos sintéticos que ejecutan una acción cuando ocurre un acontecimiento. Con los eventos declararemos cómo _react-cionarán_ nuestros componentes a la interacción con el usuario. Por ejemplo, cuando haga clic en un botón dentro de un componente que hemos definido.

## Eventos sintéticos de React

Ya hemos visto cómo escribimos código parecido a HTML con JSX que se transforma en código HTML de verdad tras pasar por React. De una manera parecida, en React tenemos un sistema de **eventos sintéticos** que usaremos como si fueran normales. Aunque están diseñados para que pasen por [eventos regulares](https://www.w3.org/TR/DOM-Level-3-Events/), igual que JSX pasa por etiquetas HTML normales, cabe destacar que son una capa que nos proporciona React y que **no son eventos reales del DOM**, y por eso se llaman **sintéticos**.

En el módulo 2 vimos los eventos del DOM y cómo escuchar eventos desde JavaScript con `addEventListener()`. También vimos una manera de hacerlo desde atributos de HTML que **recomendamos no utilizar**, pero la enseñamos por si os la encontrábais en el futuro. Las funciones escuchadoras \(_listeners_\) de React se declaran de forma parecida a aquellos que no recomendábamos. Esto no es una contradicción: recordemos que en React escribimos interfaces declarativas, y esto es solo una sintaxis comprensible para asignar comportamiento. No debéis declarar funciones escuchadoras así fuera de React.

> Cuando escuchamos un evento, declaramos una función escuchadora \(_listener_\) que se ejecutará cuando se reciba un evento de cierto tipo. Esto es así tanto para eventos del DOM como para eventos sintéticos de React, sólo cambiaremos cómo asignamos la función al tipo de evento.

Vamos a ver un ejemplo. Queremos escuchar un evento de `click` desde un botón que declaramos con JSX. Escribiremos el botón \(`<button>texto</button>`\) y en un atributo `onClick` \(ojo con la mayúscula\) añadiremos la función "escuchadora", que será la reacción. Quedará así:



```javascript
const alertButton =
  <button onClick={ /* aquí va la función */ }>
    Pedir más información
  </button>;
```

Podríamos escribir directamente la función escuchadora como una _arrow function_ ahí, pero no quedaría legible. Preferiremos declararla fuera y la pasaremos \(sin llamarla\) al atributo de JSX:

```javascript
const onClickListener = event => {
  alert('Para más información, acuda a recepción.');
};
const alertButton = (
  <button onClick={onClickListener}>Pedir más información</button>
);
```

**------&gt;&gt;&gt;&gt;&gt;&gt; POR AQUÍ** Ya está. Cuando hagamos clic en el botón, React se encargará de escuchar el evento y de ejecutar la función.

[▸ Evento simple en Codepen](https://codepen.io/adalab/pen/zppdVP?editors=0010)

Naturalmente, hay más atributos para escuchar eventos a parte de `onClick`. Los nombres de los atributos tendrán la forma `onEventoEscuchado`, con cada palabra del nombre del evento que se escucha escrita con mayúsculas iniciales. Es decir, escucharemos el evento `focus` rellenando el atributo `onFocus`, el evento `mouseover` rellenando el atributo `onMouseOver`, y así sucesivamente. Podéis consultar [el listado completo de atributos soportados](https://reactjs.org/docs/events.html#supported-events), pero a continuación vamos a listar los más usados, como ya hicimos en la sesión de eventos:

* Escuchadores de eventos de ratón:
  * `onClick`: botón izquierdo del ratón
  * `onMouseOver`: pasar el ratón sobre un elemento
  * `onMouseOut`: sacar el ratón del elemento
* Escuchadores de eventos de teclado:
  * `onKeyPress`: pulsar una tecla
* Escuchadores de eventos sobre elementos:
  * `onFocus`: poner el foco \(seleccionar\) en un elemento, por ejemplo un `<input>`
  * `onBlur`: quitar el foco de un elemento
  * `onChange`: al cambiar el contenido de un `<input>` , `<textarea>` o `<select>` \(no es necesario quitar el foco del `input` para que se considere un cambio, al contrario que en el DOM\)
* Escuchadores de eventos de formularios:
  * `onSubmit`: pulsar el botón submit del formulario
  * `onReset`: pulsar el botón reset del formulario

React no puede controlar los eventos de la ventana, así que los siguiente eventos sintéticos no existen \(sí existen sus correspondientes eventos de DOM\):

* ~~Escuchadores de eventos de la ventana~~
  * ~~`onResize`: se ha cambiado el tamaño de la ventana~~
  * ~~`onScroll`: se ha hecho scroll en la ventana o un elemento~~

